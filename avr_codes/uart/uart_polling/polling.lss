
polling.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00000350  000003c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000350  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         000006cc  00000000  00000000  000003e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000054  00000000  00000000  00000ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000020  00000000  00000000  00000b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000000f8  00000000  00000000  00000b24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000002d2  00000000  00000000  00000c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000110  00000000  00000000  00000eee  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000392  00000000  00000000  00000ffe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000f0  00000000  00000000  00001390  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000143  00000000  00000000  00001480  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000163  00000000  00000000  000015c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 0000001e  00000000  00000000  00001726  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  7c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  80:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  84:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  88:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 e5       	ldi	r30, 0x50	; 80
  a0:	f3 e0       	ldi	r31, 0x03	; 3
  a2:	02 c0       	rjmp	.+4      	; 0xa8 <__do_copy_data+0x10>
  a4:	05 90       	lpm	r0, Z+
  a6:	0d 92       	st	X+, r0
  a8:	ae 31       	cpi	r26, 0x1E	; 30
  aa:	b1 07       	cpc	r27, r17
  ac:	d9 f7       	brne	.-10     	; 0xa4 <__do_copy_data+0xc>
  ae:	0e 94 76 01 	call	0x2ec	; 0x2ec <main>
  b2:	0c 94 a6 01 	jmp	0x34c	; 0x34c <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <uart0_init>:
#include<avr/io.h>

void uart0_init(void) // INITIALIZATION FUNCTION
{
	UBRR0H = 0;
  ba:	10 92 90 00 	sts	0x0090, r1
	UBRR0L = 103; //0X67; BAUDRATE = 9600
  be:	87 e6       	ldi	r24, 0x67	; 103
  c0:	89 b9       	out	0x09, r24	; 9

	UCSR0C = 0X06;// frame : 8 bit data , no parity , stop bit
  c2:	86 e0       	ldi	r24, 0x06	; 6
  c4:	80 93 95 00 	sts	0x0095, r24
	//UCSR1C |= (1<<UCSZ1) | (1<<UCSZ0);

	UCSR0B |= (1<<RXEN) | (1<<TXEN);// ENABLE TRANSMITTER & RECEIVER
  c8:	8a b1       	in	r24, 0x0a	; 10
  ca:	88 61       	ori	r24, 0x18	; 24
  cc:	8a b9       	out	0x0a, r24	; 10
}
  ce:	08 95       	ret

000000d0 <uart0_tx_char>:

void uart0_tx_char(unsigned char data)// TRANSMISSION FUNCTION
{
	while(!(UCSR0A &(1<<UDRE)));
  d0:	5d 9b       	sbis	0x0b, 5	; 11
  d2:	fe cf       	rjmp	.-4      	; 0xd0 <uart0_tx_char>
	UDR0 = data;
  d4:	8c b9       	out	0x0c, r24	; 12
}
  d6:	08 95       	ret

000000d8 <uart0_tx_str>:

void uart0_tx_str(unsigned char *ptr) //Transmitting string
{
  d8:	ef 92       	push	r14
  da:	ff 92       	push	r15
  dc:	cf 93       	push	r28
  de:	df 93       	push	r29
  e0:	e8 2e       	mov	r14, r24
  e2:	e7 01       	movw	r28, r14
  e4:	7e 01       	movw	r14, r28
  e6:	f9 2e       	mov	r15, r25
  e8:	e7 01       	movw	r28, r14
    while(*ptr !='\0')
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <uart0_tx_str+0x18>
	{
	uart0_tx_char(*ptr);
  ec:	0e 94 68 00 	call	0xd0	; 0xd0 <uart0_tx_char>
	UDR0 = data;
}

void uart0_tx_str(unsigned char *ptr) //Transmitting string
{
    while(*ptr !='\0')
  f0:	89 91       	ld	r24, Y+
  f2:	88 23       	and	r24, r24
  f4:	d9 f7       	brne	.-10     	; 0xec <uart0_tx_str+0x14>
	{
	uart0_tx_char(*ptr);
	ptr ++;
	}
}
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	ff 90       	pop	r15
  fc:	ef 90       	pop	r14
  fe:	08 95       	ret

00000100 <uart0_tx_num>:

void uart0_tx_num(unsigned int num ) // Transmitting number
{
 100:	ef 92       	push	r14
 102:	ff 92       	push	r15
 104:	0f 93       	push	r16
 106:	1f 93       	push	r17
 108:	df 93       	push	r29
 10a:	cf 93       	push	r28
 10c:	00 d0       	rcall	.+0      	; 0x10e <uart0_tx_num+0xe>
 10e:	00 d0       	rcall	.+0      	; 0x110 <uart0_tx_num+0x10>
 110:	0f 92       	push	r0
 112:	cd b7       	in	r28, 0x3d	; 61
 114:	de b7       	in	r29, 0x3e	; 62
 116:	fe 01       	movw	r30, r28
 118:	32 96       	adiw	r30, 0x02	; 2
	uart0_tx_char(*ptr);
	ptr ++;
	}
}

void uart0_tx_num(unsigned int num ) // Transmitting number
 11a:	8e 01       	movw	r16, r28
 11c:	09 5f       	subi	r16, 0xF9	; 249
 11e:	1f 4f       	sbci	r17, 0xFF	; 255
{
	unsigned char i,count[5];	
	
	for(i=1;i<=5;i++)
	{
	count[i] = num % 10;
 120:	2a e0       	ldi	r18, 0x0A	; 10
 122:	30 e0       	ldi	r19, 0x00	; 0
 124:	b9 01       	movw	r22, r18
 126:	0e 94 92 01 	call	0x324	; 0x324 <__udivmodhi4>
 12a:	81 93       	st	Z+, r24
	num = num / 10 ;
 12c:	cb 01       	movw	r24, r22

void uart0_tx_num(unsigned int num ) // Transmitting number
{
	unsigned char i,count[5];	
	
	for(i=1;i<=5;i++)
 12e:	e0 17       	cp	r30, r16
 130:	f1 07       	cpc	r31, r17
 132:	c1 f7       	brne	.-16     	; 0x124 <uart0_tx_num+0x24>
 134:	8e 01       	movw	r16, r28
 136:	09 5f       	subi	r16, 0xF9	; 249
 138:	1f 4f       	sbci	r17, 0xFF	; 255
	uart0_tx_char(*ptr);
	ptr ++;
	}
}

void uart0_tx_num(unsigned int num ) // Transmitting number
 13a:	7e 01       	movw	r14, r28
 13c:	08 94       	sec
 13e:	e1 1c       	adc	r14, r1
 140:	f1 1c       	adc	r15, r1
 142:	08 94       	sec
 144:	e1 1c       	adc	r14, r1
 146:	f1 1c       	adc	r15, r1
	}
	i--;
	
	while(i!=0)
	{
	uart0_tx_char(count[i] + 0x30);
 148:	f8 01       	movw	r30, r16
 14a:	82 91       	ld	r24, -Z
 14c:	8f 01       	movw	r16, r30
 14e:	80 5d       	subi	r24, 0xD0	; 208
 150:	0e 94 68 00 	call	0xd0	; 0xd0 <uart0_tx_char>
	count[i] = num % 10;
	num = num / 10 ;
	}
	i--;
	
	while(i!=0)
 154:	0e 15       	cp	r16, r14
 156:	1f 05       	cpc	r17, r15
 158:	b9 f7       	brne	.-18     	; 0x148 <uart0_tx_num+0x48>
	{
	uart0_tx_char(count[i] + 0x30);
	i--;
	}
}
 15a:	0f 90       	pop	r0
 15c:	0f 90       	pop	r0
 15e:	0f 90       	pop	r0
 160:	0f 90       	pop	r0
 162:	0f 90       	pop	r0
 164:	cf 91       	pop	r28
 166:	df 91       	pop	r29
 168:	1f 91       	pop	r17
 16a:	0f 91       	pop	r16
 16c:	ff 90       	pop	r15
 16e:	ef 90       	pop	r14
 170:	08 95       	ret

00000172 <uart0_rx_char>:
unsigned char uart0_rx_char(void)
{
	while(!(UCSR0A &(1<<RXC)));
 172:	5f 9b       	sbis	0x0b, 7	; 11
 174:	fe cf       	rjmp	.-4      	; 0x172 <uart0_rx_char>
	return UDR0;
 176:	8c b1       	in	r24, 0x0c	; 12
}
 178:	08 95       	ret

0000017a <uart0_rx_str>:

void uart0_rx_str(unsigned char *ptr)
{     unsigned char i;
 17a:	ef 92       	push	r14
 17c:	ff 92       	push	r15
 17e:	0f 93       	push	r16
 180:	1f 93       	push	r17
 182:	df 93       	push	r29
 184:	cf 93       	push	r28
 186:	0f 92       	push	r0
 188:	cd b7       	in	r28, 0x3d	; 61
 18a:	de b7       	in	r29, 0x3e	; 62
      for(i=0;i<100;i++)
 18c:	48 2f       	mov	r20, r24
 18e:	59 2f       	mov	r21, r25
 190:	7a 01       	movw	r14, r20
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	87 01       	movw	r16, r14
      {
       *(ptr+i)=uart0_rx_char();
 196:	99 83       	std	Y+1, r25	; 0x01
 198:	0e 94 b9 00 	call	0x172	; 0x172 <uart0_rx_char>
 19c:	f7 01       	movw	r30, r14
 19e:	81 93       	st	Z+, r24
 1a0:	7f 01       	movw	r14, r30
        if(*(ptr+i)=='\r')
 1a2:	99 81       	ldd	r25, Y+1	; 0x01
 1a4:	8d 30       	cpi	r24, 0x0D	; 13
 1a6:	19 f4       	brne	.+6      	; 0x1ae <uart0_rx_str+0x34>
        {
        *(ptr+i)='\0';
 1a8:	f8 01       	movw	r30, r16
 1aa:	10 82       	st	Z, r1
        break;
 1ac:	03 c0       	rjmp	.+6      	; 0x1b4 <uart0_rx_str+0x3a>
	return UDR0;
}

void uart0_rx_str(unsigned char *ptr)
{     unsigned char i;
      for(i=0;i<100;i++)
 1ae:	9f 5f       	subi	r25, 0xFF	; 255
 1b0:	94 36       	cpi	r25, 0x64	; 100
 1b2:	81 f7       	brne	.-32     	; 0x194 <uart0_rx_str+0x1a>
        {
        *(ptr+i)='\0';
        break;
		}
	 }   
}
 1b4:	0f 90       	pop	r0
 1b6:	cf 91       	pop	r28
 1b8:	df 91       	pop	r29
 1ba:	1f 91       	pop	r17
 1bc:	0f 91       	pop	r16
 1be:	ff 90       	pop	r15
 1c0:	ef 90       	pop	r14
 1c2:	08 95       	ret

000001c4 <uart1_init>:
#include<avr/io.h>

// uart1 initialization
void uart1_init(void) 
{
	UBRR1H = 0;    // USART Baud Rate Registers: High & Low
 1c4:	10 92 98 00 	sts	0x0098, r1
	UBRR1L = 103; //0X67; BAUDRATE = 9600
 1c8:	87 e6       	ldi	r24, 0x67	; 103
 1ca:	80 93 99 00 	sts	0x0099, r24
	
	//UCSR : USART Control and Status Register A,B or C. 
	UCSR1C |= (1<<UCSZ1) | (1<<UCSZ0);// frame : 8 bit data ,no parity ,1 stop bit
 1ce:	ed e9       	ldi	r30, 0x9D	; 157
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	80 81       	ld	r24, Z
 1d4:	86 60       	ori	r24, 0x06	; 6
 1d6:	80 83       	st	Z, r24

	UCSR1B |= (1<<RXEN) | (1<<TXEN);// ENABLE TRANSMITTER & RECEIVER
 1d8:	ea e9       	ldi	r30, 0x9A	; 154
 1da:	f0 e0       	ldi	r31, 0x00	; 0
 1dc:	80 81       	ld	r24, Z
 1de:	88 61       	ori	r24, 0x18	; 24
 1e0:	80 83       	st	Z, r24
}
 1e2:	08 95       	ret

000001e4 <uart1_tx_char>:
void uart1_tx_char(unsigned char data)
{
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
 1e4:	90 91 9b 00 	lds	r25, 0x009B
 1e8:	95 ff       	sbrs	r25, 5
 1ea:	fc cf       	rjmp	.-8      	; 0x1e4 <uart1_tx_char>
	UDR1 = data;                //As soon as UDRE flag becomes 1,load value in data register.
 1ec:	80 93 9c 00 	sts	0x009C, r24
}
 1f0:	08 95       	ret

000001f2 <uart1_tx_str>:

//Transmitting string
void uart1_tx_str(unsigned char *ptr) 
{
 1f2:	ef 92       	push	r14
 1f4:	ff 92       	push	r15
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	e8 2e       	mov	r14, r24
 1fc:	e7 01       	movw	r28, r14
 1fe:	7e 01       	movw	r14, r28
 200:	f9 2e       	mov	r15, r25
 202:	e7 01       	movw	r28, r14
    while(*ptr !='\0')
 204:	02 c0       	rjmp	.+4      	; 0x20a <uart1_tx_str+0x18>
	{
	uart1_tx_char(*ptr);
 206:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <uart1_tx_char>
}

//Transmitting string
void uart1_tx_str(unsigned char *ptr) 
{
    while(*ptr !='\0')
 20a:	89 91       	ld	r24, Y+
 20c:	88 23       	and	r24, r24
 20e:	d9 f7       	brne	.-10     	; 0x206 <uart1_tx_str+0x14>
	{
	uart1_tx_char(*ptr);
	ptr ++; // uart1_tx_char(*(ptr++));
	}
}
 210:	df 91       	pop	r29
 212:	cf 91       	pop	r28
 214:	ff 90       	pop	r15
 216:	ef 90       	pop	r14
 218:	08 95       	ret

0000021a <uart1_tx_num>:

// Transmitting number
void uart1_tx_num(unsigned int num ) 
{
 21a:	ef 92       	push	r14
 21c:	ff 92       	push	r15
 21e:	0f 93       	push	r16
 220:	1f 93       	push	r17
 222:	df 93       	push	r29
 224:	cf 93       	push	r28
 226:	00 d0       	rcall	.+0      	; 0x228 <uart1_tx_num+0xe>
 228:	00 d0       	rcall	.+0      	; 0x22a <uart1_tx_num+0x10>
 22a:	0f 92       	push	r0
 22c:	cd b7       	in	r28, 0x3d	; 61
 22e:	de b7       	in	r29, 0x3e	; 62
 230:	fe 01       	movw	r30, r28
 232:	32 96       	adiw	r30, 0x02	; 2
	ptr ++; // uart1_tx_char(*(ptr++));
	}
}

// Transmitting number
void uart1_tx_num(unsigned int num ) 
 234:	8e 01       	movw	r16, r28
 236:	0a 5f       	subi	r16, 0xFA	; 250
 238:	1f 4f       	sbci	r17, 0xFF	; 255
{
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
	{
	count[i] = num % 10;
 23a:	2a e0       	ldi	r18, 0x0A	; 10
 23c:	30 e0       	ldi	r19, 0x00	; 0
 23e:	b9 01       	movw	r22, r18
 240:	0e 94 92 01 	call	0x324	; 0x324 <__udivmodhi4>
 244:	81 93       	st	Z+, r24
	num = num / 10 ;
 246:	cb 01       	movw	r24, r22
// Transmitting number
void uart1_tx_num(unsigned int num ) 
{
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
 248:	e0 17       	cp	r30, r16
 24a:	f1 07       	cpc	r31, r17
 24c:	c1 f7       	brne	.-16     	; 0x23e <uart1_tx_num+0x24>
 24e:	8e 01       	movw	r16, r28
 250:	0a 5f       	subi	r16, 0xFA	; 250
 252:	1f 4f       	sbci	r17, 0xFF	; 255
	ptr ++; // uart1_tx_char(*(ptr++));
	}
}

// Transmitting number
void uart1_tx_num(unsigned int num ) 
 254:	7e 01       	movw	r14, r28
 256:	08 94       	sec
 258:	e1 1c       	adc	r14, r1
 25a:	f1 1c       	adc	r15, r1
 25c:	08 94       	sec
 25e:	e1 1c       	adc	r14, r1
 260:	f1 1c       	adc	r15, r1
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
	{
	uart1_tx_char(count[i] + 0x30);
 262:	f8 01       	movw	r30, r16
 264:	82 91       	ld	r24, -Z
 266:	8f 01       	movw	r16, r30
 268:	80 5d       	subi	r24, 0xD0	; 208
 26a:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <uart1_tx_char>
	count[i] = num % 10;
	num = num / 10 ;
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
 26e:	0e 15       	cp	r16, r14
 270:	1f 05       	cpc	r17, r15
 272:	b9 f7       	brne	.-18     	; 0x262 <uart1_tx_num+0x48>
	{
	uart1_tx_char(count[i] + 0x30);
	i--;
	}
}
 274:	0f 90       	pop	r0
 276:	0f 90       	pop	r0
 278:	0f 90       	pop	r0
 27a:	0f 90       	pop	r0
 27c:	0f 90       	pop	r0
 27e:	cf 91       	pop	r28
 280:	df 91       	pop	r29
 282:	1f 91       	pop	r17
 284:	0f 91       	pop	r16
 286:	ff 90       	pop	r15
 288:	ef 90       	pop	r14
 28a:	08 95       	ret

0000028c <uart1_rx_char>:
unsigned char uart1_rx_char(void) 
{
	/*RXC flag bit is set when there are unread(NEW) data in the receive buffer
and cleared when the receive buffer is empty (i.e., does not contain any unread data).*/
	
	while(!(UCSR1A &(1<<RXC))); //Hence poll Rxc flag wait till RXC becomes 1
 28c:	80 91 9b 00 	lds	r24, 0x009B
 290:	87 ff       	sbrs	r24, 7
 292:	fc cf       	rjmp	.-8      	; 0x28c <uart1_rx_char>
	return UDR1;
 294:	80 91 9c 00 	lds	r24, 0x009C
}
 298:	08 95       	ret

0000029a <uart1_rx_str>:

// Receiving string
char *uart1_rx_str(void)
{   
 29a:	0f 93       	push	r16
 29c:	1f 93       	push	r17
 29e:	cf 93       	push	r28
 2a0:	df 93       	push	r29
 2a2:	c0 e0       	ldi	r28, 0x00	; 0
 2a4:	d0 e0       	ldi	r29, 0x00	; 0
 2a6:	8e 01       	movw	r16, r28
 unsigned char *ptr=0,i=0;
  while(i!=100){
    
    *(ptr+i) = uart1_rx_char();
 2a8:	0e 94 46 01 	call	0x28c	; 0x28c <uart1_rx_char>
 2ac:	88 83       	st	Y, r24
    uart1_tx_char(*(ptr+i));
 2ae:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <uart1_tx_char>
    if(*(ptr+i)=='\r'){
 2b2:	89 91       	ld	r24, Y+
 2b4:	8d 30       	cpi	r24, 0x0D	; 13
 2b6:	61 f4       	brne	.+24     	; 0x2d0 <uart1_rx_str+0x36>
      *(ptr+i) = "NULL";
 2b8:	80 e0       	ldi	r24, 0x00	; 0
 2ba:	91 e0       	ldi	r25, 0x01	; 1
 2bc:	f8 01       	movw	r30, r16
 2be:	80 83       	st	Z, r24
      
      uart1_tx_char('\n');
 2c0:	8a e0       	ldi	r24, 0x0A	; 10
 2c2:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <uart1_tx_char>
      uart1_tx_str("Null added successfully");
 2c6:	85 e0       	ldi	r24, 0x05	; 5
 2c8:	91 e0       	ldi	r25, 0x01	; 1
 2ca:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <uart1_tx_str>
      break;
 2ce:	03 c0       	rjmp	.+6      	; 0x2d6 <uart1_rx_str+0x3c>

// Receiving string
char *uart1_rx_str(void)
{   
 unsigned char *ptr=0,i=0;
  while(i!=100){
 2d0:	c4 36       	cpi	r28, 0x64	; 100
 2d2:	d1 05       	cpc	r29, r1
 2d4:	41 f7       	brne	.-48     	; 0x2a6 <uart1_rx_str+0xc>
        break;
		}
       } */
    return ptr;

}
 2d6:	80 e0       	ldi	r24, 0x00	; 0
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	df 91       	pop	r29
 2dc:	cf 91       	pop	r28
 2de:	1f 91       	pop	r17
 2e0:	0f 91       	pop	r16
 2e2:	08 95       	ret

000002e4 <uart1_rx_num>:
unsigned char uart1_rx_num(void)
{
	unsigned char num;
	while(1)
	{
	num = uart1_rx_char();
 2e4:	0e 94 46 01 	call	0x28c	; 0x28c <uart1_rx_char>
	num = num - 0x30;
	return num;
	}
}
 2e8:	80 53       	subi	r24, 0x30	; 48
 2ea:	08 95       	ret

000002ec <main>:
#include<util/delay.h>
#include"uart0.h"
#include"uart1.h"
int main(void)
{
 2ec:	ef 92       	push	r14
 2ee:	ff 92       	push	r15
 2f0:	cf 93       	push	r28
 2f2:	df 93       	push	r29

	uart1_init() ; // uart1 initialization
 2f4:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <uart1_init>
	unsigned char *ch;
	//unsigned char data;
	
	//while(1)
	//{
	*ch=0;
 2f8:	10 92 00 00 	sts	0x0000, r1
	ch = uart1_rx_str();
 2fc:	0e 94 4d 01 	call	0x29a	; 0x29a <uart1_rx_str>
 300:	e8 2e       	mov	r14, r24
 302:	e7 01       	movw	r28, r14
 304:	7e 01       	movw	r14, r28
 306:	f9 2e       	mov	r15, r25
 308:	e7 01       	movw	r28, r14
	while(*ch!='\0'){
 30a:	02 c0       	rjmp	.+4      	; 0x310 <main+0x24>
	uart1_tx_char(*ch);
 30c:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <uart1_tx_char>
	
	//while(1)
	//{
	*ch=0;
	ch = uart1_rx_str();
	while(*ch!='\0'){
 310:	89 91       	ld	r24, Y+
 312:	88 23       	and	r24, r24
 314:	d9 f7       	brne	.-10     	; 0x30c <main+0x20>
	//data = uart0_rx_char();
	//uart1_tx_char(data);
	//} 
	
	 
}
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	df 91       	pop	r29
 31c:	cf 91       	pop	r28
 31e:	ff 90       	pop	r15
 320:	ef 90       	pop	r14
 322:	08 95       	ret

00000324 <__udivmodhi4>:
 324:	aa 1b       	sub	r26, r26
 326:	bb 1b       	sub	r27, r27
 328:	51 e1       	ldi	r21, 0x11	; 17
 32a:	07 c0       	rjmp	.+14     	; 0x33a <__udivmodhi4_ep>

0000032c <__udivmodhi4_loop>:
 32c:	aa 1f       	adc	r26, r26
 32e:	bb 1f       	adc	r27, r27
 330:	a6 17       	cp	r26, r22
 332:	b7 07       	cpc	r27, r23
 334:	10 f0       	brcs	.+4      	; 0x33a <__udivmodhi4_ep>
 336:	a6 1b       	sub	r26, r22
 338:	b7 0b       	sbc	r27, r23

0000033a <__udivmodhi4_ep>:
 33a:	88 1f       	adc	r24, r24
 33c:	99 1f       	adc	r25, r25
 33e:	5a 95       	dec	r21
 340:	a9 f7       	brne	.-22     	; 0x32c <__udivmodhi4_loop>
 342:	80 95       	com	r24
 344:	90 95       	com	r25
 346:	bc 01       	movw	r22, r24
 348:	cd 01       	movw	r24, r26
 34a:	08 95       	ret

0000034c <_exit>:
 34c:	f8 94       	cli

0000034e <__stop_program>:
 34e:	ff cf       	rjmp	.-2      	; 0x34e <__stop_program>
