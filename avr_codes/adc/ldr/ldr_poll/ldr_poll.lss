
ldr_poll.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001a  00800100  00000270  000002e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000270  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000020  00000000  00000000  000002fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000ac  00000000  00000000  0000031e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000322  00000000  00000000  000003ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000001f1  00000000  00000000  000006ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000334  00000000  00000000  000008dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000b0  00000000  00000000  00000c14  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000012e  00000000  00000000  00000cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000000bc  00000000  00000000  00000df2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00000eae  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  7c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  80:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  84:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  88:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e0 e7       	ldi	r30, 0x70	; 112
  a0:	f2 e0       	ldi	r31, 0x02	; 2
  a2:	02 c0       	rjmp	.+4      	; 0xa8 <.do_copy_data_start>

000000a4 <.do_copy_data_loop>:
  a4:	05 90       	lpm	r0, Z+
  a6:	0d 92       	st	X+, r0

000000a8 <.do_copy_data_start>:
  a8:	aa 31       	cpi	r26, 0x1A	; 26
  aa:	b1 07       	cpc	r27, r17
  ac:	d9 f7       	brne	.-10     	; 0xa4 <.do_copy_data_loop>
  ae:	0e 94 13 01 	call	0x226	; 0x226 <main>
  b2:	0c 94 36 01 	jmp	0x26c	; 0x26c <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <uart1_init>:
#include<avr/io.h>

// uart1 initialization
void uart1_init(void) 
{
	UBRR1H = 0;    // USART Baud Rate Registers: High & Low
  ba:	10 92 98 00 	sts	0x0098, r1
	UBRR1L = 103; //0X67; BAUDRATE = 9600
  be:	87 e6       	ldi	r24, 0x67	; 103
  c0:	80 93 99 00 	sts	0x0099, r24
	
	//UCSR : USART Control and Status Register A,B or C. 
	UCSR1C |= (1<<UCSZ1) | (1<<UCSZ0);// frame : 8 bit data ,no parity ,1 stop bit
  c4:	ed e9       	ldi	r30, 0x9D	; 157
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	80 81       	ld	r24, Z
  ca:	86 60       	ori	r24, 0x06	; 6
  cc:	80 83       	st	Z, r24

	UCSR1B |= (1<<RXEN) | (1<<TXEN);// ENABLE TRANSMITTER & RECEIVER
  ce:	ea e9       	ldi	r30, 0x9A	; 154
  d0:	f0 e0       	ldi	r31, 0x00	; 0
  d2:	80 81       	ld	r24, Z
  d4:	88 61       	ori	r24, 0x18	; 24
  d6:	80 83       	st	Z, r24
}
  d8:	08 95       	ret

000000da <uart1_tx_char>:

// Trannitting Char
void uart1_tx_char(unsigned char data)
{
  da:	98 2f       	mov	r25, r24
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
  dc:	80 91 9b 00 	lds	r24, 0x009B
  e0:	85 ff       	sbrs	r24, 5
  e2:	fc cf       	rjmp	.-8      	; 0xdc <uart1_tx_char+0x2>
	UDR1 = data;                //As soon as UDRE flag becomes 1,load value in data register.
  e4:	90 93 9c 00 	sts	0x009C, r25
}
  e8:	08 95       	ret

000000ea <uart1_tx_str>:

//Transmitting string
void uart1_tx_str(unsigned char *ptr) 
{
  ea:	fc 01       	movw	r30, r24
  ec:	07 c0       	rjmp	.+14     	; 0xfc <uart1_tx_str+0x12>
void uart1_tx_char(unsigned char data)
{
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
  ee:	80 91 9b 00 	lds	r24, 0x009B
  f2:	85 ff       	sbrs	r24, 5
  f4:	fc cf       	rjmp	.-8      	; 0xee <uart1_tx_str+0x4>
	UDR1 = data;                //As soon as UDRE flag becomes 1,load value in data register.
  f6:	90 93 9c 00 	sts	0x009C, r25
void uart1_tx_str(unsigned char *ptr) 
{
    while(*ptr !='\0')
	{
	uart1_tx_char(*ptr);
	ptr ++; // uart1_tx_char(*(ptr++));
  fa:	31 96       	adiw	r30, 0x01	; 1
}

//Transmitting string
void uart1_tx_str(unsigned char *ptr) 
{
    while(*ptr !='\0')
  fc:	90 81       	ld	r25, Z
  fe:	99 23       	and	r25, r25
 100:	b1 f7       	brne	.-20     	; 0xee <uart1_tx_str+0x4>
	{
	uart1_tx_char(*ptr);
	ptr ++; // uart1_tx_char(*(ptr++));
	}
}
 102:	08 95       	ret

00000104 <uart1_tx_num>:

// Transmitting number
void uart1_tx_num(unsigned int num ) 
{
 104:	df 93       	push	r29
 106:	cf 93       	push	r28
 108:	00 d0       	rcall	.+0      	; 0x10a <uart1_tx_num+0x6>
 10a:	00 d0       	rcall	.+0      	; 0x10c <uart1_tx_num+0x8>
 10c:	0f 92       	push	r0
 10e:	cd b7       	in	r28, 0x3d	; 61
 110:	de b7       	in	r29, 0x3e	; 62
 112:	9c 01       	movw	r18, r24
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
	{
	count[i] = num % 10;
 114:	6a e0       	ldi	r22, 0x0A	; 10
 116:	70 e0       	ldi	r23, 0x00	; 0
 118:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 11c:	8a 83       	std	Y+2, r24	; 0x02
	num = num / 10 ;
 11e:	c9 01       	movw	r24, r18
 120:	6a e0       	ldi	r22, 0x0A	; 10
 122:	70 e0       	ldi	r23, 0x00	; 0
 124:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 128:	9b 01       	movw	r18, r22
{
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
	{
	count[i] = num % 10;
 12a:	cb 01       	movw	r24, r22
 12c:	6a e0       	ldi	r22, 0x0A	; 10
 12e:	70 e0       	ldi	r23, 0x00	; 0
 130:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 134:	8b 83       	std	Y+3, r24	; 0x03
	num = num / 10 ;
 136:	c9 01       	movw	r24, r18
 138:	6a e0       	ldi	r22, 0x0A	; 10
 13a:	70 e0       	ldi	r23, 0x00	; 0
 13c:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 140:	9b 01       	movw	r18, r22
{
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
	{
	count[i] = num % 10;
 142:	cb 01       	movw	r24, r22
 144:	6a e0       	ldi	r22, 0x0A	; 10
 146:	70 e0       	ldi	r23, 0x00	; 0
 148:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 14c:	8c 83       	std	Y+4, r24	; 0x04
 14e:	c9 01       	movw	r24, r18
 150:	6a e0       	ldi	r22, 0x0A	; 10
 152:	70 e0       	ldi	r23, 0x00	; 0
 154:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 158:	cb 01       	movw	r24, r22
 15a:	6a e0       	ldi	r22, 0x0A	; 10
 15c:	70 e0       	ldi	r23, 0x00	; 0
 15e:	0e 94 22 01 	call	0x244	; 0x244 <__udivmodhi4>
 162:	8d 83       	std	Y+5, r24	; 0x05
 164:	fe 01       	movw	r30, r28
 166:	35 96       	adiw	r30, 0x05	; 5
	num = num / 10 ;
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
 168:	9e 01       	movw	r18, r28
 16a:	2f 5f       	subi	r18, 0xFF	; 255
 16c:	3f 4f       	sbci	r19, 0xFF	; 255
	{
	uart1_tx_char(count[i] + 0x30);
 16e:	90 81       	ld	r25, Z
void uart1_tx_char(unsigned char data)
{
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
 170:	80 91 9b 00 	lds	r24, 0x009B
 174:	85 ff       	sbrs	r24, 5
 176:	fc cf       	rjmp	.-8      	; 0x170 <uart1_tx_num+0x6c>
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
	{
	uart1_tx_char(count[i] + 0x30);
 178:	90 5d       	subi	r25, 0xD0	; 208
{
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
	UDR1 = data;                //As soon as UDRE flag becomes 1,load value in data register.
 17a:	90 93 9c 00 	sts	0x009C, r25
 17e:	31 97       	sbiw	r30, 0x01	; 1
	count[i] = num % 10;
	num = num / 10 ;
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
 180:	2e 17       	cp	r18, r30
 182:	3f 07       	cpc	r19, r31
 184:	a1 f7       	brne	.-24     	; 0x16e <uart1_tx_num+0x6a>
	{
	uart1_tx_char(count[i] + 0x30);
	i--;
	}
}
 186:	0f 90       	pop	r0
 188:	0f 90       	pop	r0
 18a:	0f 90       	pop	r0
 18c:	0f 90       	pop	r0
 18e:	0f 90       	pop	r0
 190:	cf 91       	pop	r28
 192:	df 91       	pop	r29
 194:	08 95       	ret

00000196 <uart1_rx_char>:
unsigned char uart1_rx_char(void) 
{
	/*RXC flag bit is set when there are unread(NEW) data in the receive buffer
and cleared when the receive buffer is empty (i.e., does not contain any unread data).*/
	
	while(!(UCSR1A &(1<<RXC))); //Hence poll Rxc flag wait till RXC becomes 1
 196:	80 91 9b 00 	lds	r24, 0x009B
 19a:	87 ff       	sbrs	r24, 7
 19c:	fc cf       	rjmp	.-8      	; 0x196 <uart1_rx_char>
	return UDR1;
 19e:	80 91 9c 00 	lds	r24, 0x009C
}
 1a2:	08 95       	ret

000001a4 <uart1_rx_str>:

// Receiving string
void uart1_rx_str(unsigned char *ptr)
{     unsigned int i;
 1a4:	fc 01       	movw	r30, r24
 1a6:	20 e0       	ldi	r18, 0x00	; 0
 1a8:	30 e0       	ldi	r19, 0x00	; 0
unsigned char uart1_rx_char(void) 
{
	/*RXC flag bit is set when there are unread(NEW) data in the receive buffer
and cleared when the receive buffer is empty (i.e., does not contain any unread data).*/
	
	while(!(UCSR1A &(1<<RXC))); //Hence poll Rxc flag wait till RXC becomes 1
 1aa:	80 91 9b 00 	lds	r24, 0x009B
 1ae:	87 ff       	sbrs	r24, 7
 1b0:	fc cf       	rjmp	.-8      	; 0x1aa <uart1_rx_str+0x6>
	return UDR1;
 1b2:	80 91 9c 00 	lds	r24, 0x009C
// Receiving string
void uart1_rx_str(unsigned char *ptr)
{     unsigned int i;
      for(i=0;i<100;i++)
      {
       *(ptr+i)=uart1_rx_char();
 1b6:	80 83       	st	Z, r24
        if(*(ptr+i)=='\r')
 1b8:	8d 30       	cpi	r24, 0x0D	; 13
 1ba:	11 f4       	brne	.+4      	; 0x1c0 <uart1_rx_str+0x1c>
        {
        *(ptr+i)='\0';
 1bc:	10 82       	st	Z, r1
 1be:	08 95       	ret
}

// Receiving string
void uart1_rx_str(unsigned char *ptr)
{     unsigned int i;
      for(i=0;i<100;i++)
 1c0:	2f 5f       	subi	r18, 0xFF	; 255
 1c2:	3f 4f       	sbci	r19, 0xFF	; 255
 1c4:	31 96       	adiw	r30, 0x01	; 1
 1c6:	24 36       	cpi	r18, 0x64	; 100
 1c8:	31 05       	cpc	r19, r1
 1ca:	79 f7       	brne	.-34     	; 0x1aa <uart1_rx_str+0x6>
 1cc:	08 95       	ret

000001ce <uart1_rx_num>:
unsigned char uart1_rx_char(void) 
{
	/*RXC flag bit is set when there are unread(NEW) data in the receive buffer
and cleared when the receive buffer is empty (i.e., does not contain any unread data).*/
	
	while(!(UCSR1A &(1<<RXC))); //Hence poll Rxc flag wait till RXC becomes 1
 1ce:	80 91 9b 00 	lds	r24, 0x009B
 1d2:	87 ff       	sbrs	r24, 7
 1d4:	fc cf       	rjmp	.-8      	; 0x1ce <uart1_rx_num>
	return UDR1;
 1d6:	80 91 9c 00 	lds	r24, 0x009C
	{
	num = uart1_rx_char();
	num = num - 0x30;
	return num;
	}
}
 1da:	80 53       	subi	r24, 0x30	; 48
 1dc:	08 95       	ret

000001de <ldr_init>:
void ldr_init(void)
{
ADMUX|=(1<<REFS1)|(1<<REFS0);//Internal 2.56V Voltage Reference,
 1de:	87 b1       	in	r24, 0x07	; 7
 1e0:	80 6c       	ori	r24, 0xC0	; 192
 1e2:	87 b9       	out	0x07, r24	; 7
//ADLAR=0- Right alligned (10 bit resolutn), MUX 4:0 = 00000 - Single Ended Input ADC0 CHANNEL. 
//LDR sensor is connected to channel 0 of the Atmega64 microcontroller.

ADCSRA|=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
 1e4:	86 b1       	in	r24, 0x06	; 6
 1e6:	87 68       	ori	r24, 0x87	; 135
 1e8:	86 b9       	out	0x06, r24	; 6
/*ADC Enable; ADPS bits determine the division factor between the XTAL frequency 
and the input clock to the ADC,ADC Prescaler=128 selected*/
}
 1ea:	08 95       	ret

000001ec <ldr_read>:
void ldr_read(void)
{
unsigned char b=0;
unsigned int a=0;// Declaring as int for storing 10 bit data

ADCSRA|=(1<<ADSC);// ALWAYS SET START CONV BIT FOR NORMAL MODE
 1ec:	36 9a       	sbi	0x06, 6	; 6
while(!(ADCSRA&(1<<ADIF)));//ADIF bit is set when an ADC conversion completes 
 1ee:	34 9b       	sbis	0x06, 4	; 6
 1f0:	fe cf       	rjmp	.-4      	; 0x1ee <ldr_read+0x2>
//and the data registers are updated ,hence wait till ADIF BECOMES 1

b=ADCL;//Read Lower Result Data Reg
 1f2:	24 b1       	in	r18, 0x04	; 4
a=ADCH;//Read higher Result Data Reg
 1f4:	45 b1       	in	r20, 0x05	; 5
a=(b|(a<<8));//combine two result (Refer notebook )
 1f6:	94 2f       	mov	r25, r20
 1f8:	80 e0       	ldi	r24, 0x00	; 0

uart1_tx_num(a);
 1fa:	30 e0       	ldi	r19, 0x00	; 0
 1fc:	82 2b       	or	r24, r18
 1fe:	93 2b       	or	r25, r19
 200:	0e 94 82 00 	call	0x104	; 0x104 <uart1_tx_num>
void uart1_tx_char(unsigned char data)
{
	/*The UDREn(USART Data Register Empty) flag indicates if the transmit buffer (UDR) is ready to receive new data. 
If UDREn is one, the buffer is empty, and therefore ready to be written*/

	while(!(UCSR1A &(1<<UDRE)));//Hence poll UDRE flag till UDRE becomes 1
 204:	80 91 9b 00 	lds	r24, 0x009B
 208:	85 ff       	sbrs	r24, 5
 20a:	fc cf       	rjmp	.-8      	; 0x204 <ldr_read+0x18>
	UDR1 = data;                //As soon as UDRE flag becomes 1,load value in data register.
 20c:	89 e0       	ldi	r24, 0x09	; 9
 20e:	80 93 9c 00 	sts	0x009C, r24
 212:	88 e8       	ldi	r24, 0x88	; 136
 214:	93 e1       	ldi	r25, 0x13	; 19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 216:	20 e9       	ldi	r18, 0x90	; 144
 218:	31 e0       	ldi	r19, 0x01	; 1
 21a:	f9 01       	movw	r30, r18
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	f1 f7       	brne	.-4      	; 0x21c <ldr_read+0x30>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 220:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 222:	d9 f7       	brne	.-10     	; 0x21a <ldr_read+0x2e>
_delay_ms(500);
/*
lcd_showvalue(a);
_delay_ms(500);
*/
}
 224:	08 95       	ret

00000226 <main>:
void ldr_init(void)
{
ADMUX|=(1<<REFS1)|(1<<REFS0);//Internal 2.56V Voltage Reference,
 226:	87 b1       	in	r24, 0x07	; 7
 228:	80 6c       	ori	r24, 0xC0	; 192
 22a:	87 b9       	out	0x07, r24	; 7
//ADLAR=0- Right alligned (10 bit resolutn), MUX 4:0 = 00000 - Single Ended Input ADC0 CHANNEL. 
//LDR sensor is connected to channel 0 of the Atmega64 microcontroller.

ADCSRA|=(1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
 22c:	86 b1       	in	r24, 0x06	; 6
 22e:	87 68       	ori	r24, 0x87	; 135
 230:	86 b9       	out	0x06, r24	; 6
#include"ldr_poll.h"
int main(void)
{
ldr_init();

uart1_init();
 232:	0e 94 5d 00 	call	0xba	; 0xba <uart1_init>
uart1_tx_str("uart has initialised....\n");
 236:	80 e0       	ldi	r24, 0x00	; 0
 238:	91 e0       	ldi	r25, 0x01	; 1
 23a:	0e 94 75 00 	call	0xea	; 0xea <uart1_tx_str>
/*lcd_init();
lcd_putchar('A');*/

while(1)
    {
		ldr_read();
 23e:	0e 94 f6 00 	call	0x1ec	; 0x1ec <ldr_read>
 242:	fd cf       	rjmp	.-6      	; 0x23e <main+0x18>

00000244 <__udivmodhi4>:
 244:	aa 1b       	sub	r26, r26
 246:	bb 1b       	sub	r27, r27
 248:	51 e1       	ldi	r21, 0x11	; 17
 24a:	07 c0       	rjmp	.+14     	; 0x25a <__udivmodhi4_ep>

0000024c <__udivmodhi4_loop>:
 24c:	aa 1f       	adc	r26, r26
 24e:	bb 1f       	adc	r27, r27
 250:	a6 17       	cp	r26, r22
 252:	b7 07       	cpc	r27, r23
 254:	10 f0       	brcs	.+4      	; 0x25a <__udivmodhi4_ep>
 256:	a6 1b       	sub	r26, r22
 258:	b7 0b       	sbc	r27, r23

0000025a <__udivmodhi4_ep>:
 25a:	88 1f       	adc	r24, r24
 25c:	99 1f       	adc	r25, r25
 25e:	5a 95       	dec	r21
 260:	a9 f7       	brne	.-22     	; 0x24c <__udivmodhi4_loop>
 262:	80 95       	com	r24
 264:	90 95       	com	r25
 266:	bc 01       	movw	r22, r24
 268:	cd 01       	movw	r24, r26
 26a:	08 95       	ret

0000026c <_exit>:
 26c:	f8 94       	cli

0000026e <__stop_program>:
 26e:	ff cf       	rjmp	.-2      	; 0x26e <__stop_program>
