
adc.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000008f0  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ctors        00000000  000008f0  000008f0  00010000  2**0
                  CONTENTS
  2 .dtors        00000000  000008f0  000008f0  00010000  2**0
                  CONTENTS
  3 .data         00000000  40000000  000008f0  00010000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000004  40000000  40000000  00010000  2**2
                  ALLOC
  5 .stack        00000400  40000100  40000100  00010000  2**0
                  CONTENTS
  6 .stab         00001b18  00000000  00000000  00010400  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .stabstr      00001c4e  00000000  00000000  00011f18  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      00000030  00000000  00000000  00013b66  2**0
                  CONTENTS, READONLY
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        ldr   pc,_undf                  // undefined - _undf
   4:	e59ff014 	ldr	pc, [pc, #20]	; 20 <_undf>
        ldr   pc,_swi                   // SWI - _swi
   8:	e59ff014 	ldr	pc, [pc, #20]	; 24 <_swi>
        ldr   pc,_pabt                  // program abort - _pabt
   c:	e59ff014 	ldr	pc, [pc, #20]	; 28 <_pabt>
        ldr   pc,_dabt                  // data abort - _dabt
  10:	e59ff014 	ldr	pc, [pc, #20]	; 2c <_dabt>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xbfffeb30>
        ldr   pc,_fiq                   // FIQ - _fiq
  1c:	e59ff010 	ldr	pc, [pc, #16]	; 34 <_fiq>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <F_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack
  50:	e59f00c0 	ldr	r0, [pc, #192]	; 118 <_reset+0x4>
        msr   CPSR_c,#MODE_UND|I_BIT|F_BIT // Undefined Instruction Mode
  54:	e321f0db 	msr	CPSR_c, #219	; 0xdb
        mov   sp,r0
  58:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#UND_STACK_SIZE
  5c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_ABT|I_BIT|F_BIT // Abort Mode
  60:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
        mov   sp,r0
  64:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#ABT_STACK_SIZE
  68:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_FIQ|I_BIT|F_BIT // FIQ Mode
  6c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
        mov   sp,r0
  70:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#FIQ_STACK_SIZE
  74:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_IRQ|I_BIT|F_BIT // IRQ Mode
  78:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
        mov   sp,r0
  7c:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#IRQ_STACK_SIZE
  80:	e2400080 	sub	r0, r0, #128	; 0x80
        msr   CPSR_c,#MODE_SVC|I_BIT|F_BIT // Supervisor Mode
  84:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
        mov   sp,r0
  88:	e1a0d000 	mov	sp, r0
        sub   r0,r0,#SVC_STACK_SIZE
  8c:	e2400004 	sub	r0, r0, #4	; 0x4
        msr   CPSR_c,#MODE_SYS|I_BIT|F_BIT // System Mode
  90:	e321f0df 	msr	CPSR_c, #223	; 0xdf
        mov   sp,r0
  94:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -----------------------------------------------------
#ifdef ROM_RUN
        ldr   r1,=_etext                // -> ROM data start
  98:	e59f107c 	ldr	r1, [pc, #124]	; 11c <_reset+0x8>
        ldr   r2,=_data                 // -> data start
  9c:	e59f207c 	ldr	r2, [pc, #124]	; 120 <_reset+0xc>
        ldr   r3,=_edata                // -> end of data
  a0:	e59f307c 	ldr	r3, [pc, #124]	; 124 <_reset+0x10>
1:      cmp   r2,r3                     // check if data to move
  a4:	e1520003 	cmp	r2, r3
        ldrlo r0,[r1],#4                // copy it
  a8:	34910004 	ldrcc	r0, [r1], #4
        strlo r0,[r2],#4
  ac:	34820004 	strcc	r0, [r2], #4
        blo   1b                        // loop until done
  b0:	3afffffb 	bcc	a4 <IRQ_STACK_SIZE+0x24>
#endif
// Clear .bss
// ----------
        mov   r0,#0                     // get a zero
  b4:	e3a00000 	mov	r0, #0	; 0x0
        ldr   r1,=__bss_start           // -> bss start
  b8:	e59f1068 	ldr	r1, [pc, #104]	; 128 <_reset+0x14>
        ldr   r2,=__bss_end__           // -> bss end
  bc:	e59f2068 	ldr	r2, [pc, #104]	; 12c <_reset+0x18>
2:      cmp   r1,r2                     // check if data to clear
  c0:	e1510002 	cmp	r1, r2
        strlo r0,[r1],#4                // clear 4 bytes
  c4:	34810004 	strcc	r0, [r1], #4
        blo   2b                        // loop until done
  c8:	3afffffc 	bcc	c0 <IRQ_STACK_SIZE+0x40>
		
/*
   Call C++ constructors (for objects in "global scope")
   ctor loop added by Martin Thomas 4/2005 
   based on a Anglia Design example-application for ST ARM
*/

		LDR 	r0, =__ctors_start__
  cc:	e59f005c 	ldr	r0, [pc, #92]	; 130 <_reset+0x1c>
		LDR 	r1, =__ctors_end__
  d0:	e59f105c 	ldr	r1, [pc, #92]	; 134 <_reset+0x20>

000000d4 <ctor_loop>:
ctor_loop:
		CMP 	r0, r1
  d4:	e1500001 	cmp	r0, r1
		BEQ 	ctor_end
  d8:	0a000005 	beq	f4 <ctor_end>
		LDR 	r2, [r0], #4
  dc:	e4902004 	ldr	r2, [r0], #4
		STMFD 	sp!, {r0-r1}
  e0:	e92d0003 	stmdb	sp!, {r0, r1}
		MOV 	lr, pc
  e4:	e1a0e00f 	mov	lr, pc
		MOV 	pc, r2
  e8:	e1a0f002 	mov	pc, r2
		LDMFD 	sp!, {r0-r1}
  ec:	e8bd0003 	ldmia	sp!, {r0, r1}
		B 		ctor_loop
  f0:	eafffff7 	b	d4 <ctor_loop>

000000f4 <ctor_end>:
ctor_end:

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  f4:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
  f8:	e1a01000 	mov	r1, r0
        mov   r2,r0
  fc:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
 100:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
 104:	e1a07000 	mov	r7, r0
        ldr   r10,=main
 108:	e59fa028 	ldr	sl, [pc, #40]	; 138 <_reset+0x24>
        mov   lr,pc
 10c:	e1a0e00f 	mov	lr, pc

/* Enter the C code, use BX instruction so as to never return */
/* use BLX (?) main if you want to use c++ destructors below */

        bx    r10                       // enter main()
 110:	e12fff1a 	bx	sl

00000114 <_reset>:

/* "global object"-dtors are never called and it should not be 
   needed since there is no OS to exit to. */
/* Call destructors */
#		LDR		r0, =__dtors_start__
#		LDR		r1, =__dtors_end__
dtor_loop:
#		CMP		r0, r1
#		BEQ		dtor_end
#		LDR		r2, [r0], #4
#		STMFD	sp!, {r0-r1}
#		MOV		lr, pc
#		MOV		pc, r2
#		LDMFD	sp!, {r0-r1}
#		B		dtor_loop
dtor_end:
   
        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:
#if 0
// Disable interrupts, then force a hardware reset by driving P23 low
// -------------------------------------------------------------------
        mrs   r0,cpsr                   // get PSR
        orr   r0,r0,#I_BIT|F_BIT        // disable IRQ and FIQ
        msr   cpsr,r0                   // set up status register

        ldr   r1,=(PS_BASE)             // PS Base Address
        ldr   r0,=(PS_PIO)              // PIO Module
        str   r0,[r1,#PS_PCER_OFF]      // enable its clock
        ldr   r1,=(PIO_BASE)            // PIO Base Address
        ldr   r0,=(1<<23)               // P23
        str   r0,[r1,#PIO_PER_OFF]      // make sure pin is contolled by PIO
        str   r0,[r1,#PIO_CODR_OFF]     // set the pin low
        str   r0,[r1,#PIO_OER_OFF]      // make it an output
#endif
        b     .                         // loop until reset
 114:	eafffffe 	b	114 <_reset>
 118:	40000500 	andmi	r0, r0, r0, lsl #10
 11c:	000008f0 	streqd	r0, [r0], -r0
 120:	40000000 	andmi	r0, r0, r0
 124:	40000000 	andmi	r0, r0, r0
 128:	40000000 	andmi	r0, r0, r0
 12c:	40000004 	andmi	r0, r0, r4
 130:	000008f0 	streqd	r0, [r0], -r0
 134:	000008f0 	streqd	r0, [r0], -r0
 138:	000008c4 	andeq	r0, r0, r4, asr #17

0000013c <IRQ_Routine>:
/*  ----------------------------------------------------  */
void IRQ_Routine(void)
{

    while (1);
 13c:	eafffffe 	b	13c <IRQ_Routine>

00000140 <FIQ_Routine>:
}
void FIQ_Routine(void)
{
    while (1);
 140:	eafffffe 	b	140 <FIQ_Routine>

00000144 <SWI_Routine>:
}
void SWI_Routine(void)
{
    while (1);
 144:	eafffffe 	b	144 <SWI_Routine>

00000148 <UNDEF_Routine>:
}
void UNDEF_Routine(void)
{
    while (1);
 148:	eafffffe 	b	148 <UNDEF_Routine>

0000014c <feed>:
}


/**********************************************************
                      Initialize
**********************************************************/

#define PLOCK 0x400
static void feed(void)
{
    PLLFEED = 0xAA;
 14c:	e59f3010 	ldr	r3, [pc, #16]	; 164 <feed+0x18>
 150:	e3a020aa 	mov	r2, #170	; 0xaa
 154:	e5832000 	str	r2, [r3]
    PLLFEED = 0x55;
 158:	e3a02055 	mov	r2, #85	; 0x55
 15c:	e5832000 	str	r2, [r3]
 160:	e1a0f00e 	mov	pc, lr
 164:	e01fc08c 	ands	ip, pc, ip, lsl #1

00000168 <sys_init>:
} void sys_init(void)
{

    //                              Setting the Phased Lock Loop (PLL)
    //               ----------------------------------
    //
    // LPC-P2148 has a 12.0000 mhz crystal
    //
    // We'd like the LPC2148 to run at 60 mhz (has to be an even multiple of crystal)
    // 
    // According to the Philips LPC2148 manual:   M = cclk / Fosc   where:  M    = PLL multiplier (bits 0-4 of PLLCFG)
    //                                                                                                                                              cclk = 60000000 hz
    //                                                                                                                                              Fosc = 12000000 hz
    //
    // Solving:     M = 60000000 / 12000000 = 5           
    //
    //                      Note: M - 1 must be entered into bits 0-4 of PLLCFG (assign 4 to these bits)
    //
    //
    // The Current Controlled Oscilator (CCO) must operate in the range 156 mhz to 320 mhz
    //
    // According to the Philips LPC2148 manual:     Fcco = cclk * 2 * P    where:   Fcco = CCO frequency 
    //                                                                                                                                                      cclk = 60000000 hz
    //                                                                                                                                                      P = PLL divisor (bits 5-6 of PLLCFG)
    //
    // Solving:     Fcco = 60000000 * 2 * P
    //                      P = 2  (trial value)
    //                      Fcco = 60000000 * 2 * 2
    //                      Fcc0 = 240000000 hz    (good choice for P since it's within the 156 mhz to 320 mhz range)
    //
    // From Table 22 (page 34) of Philips LPC2148 manual    P = 2, PLLCFG bits 5-6 = 1  (assign 1 to these bits)
    //
    // Finally:      PLLCFG = 0  01  00100  =  0x24
    //
    // Final note: to load PLLCFG register, we must use the 0xAA followed 0x55 write sequence to the PLLFEED register
    //             this is done in the short function feed() below
    //

    // Setting Multiplier and Divider values
    PLLCFG = 0x24;
 168:	e59f3068 	ldr	r3, [pc, #104]	; 1d8 <sys_init+0x70>
 16c:	e1a0c00d 	mov	ip, sp
 170:	e3a02024 	mov	r2, #36	; 0x24
 174:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
 178:	e5832000 	str	r2, [r3]
 17c:	e24cb004 	sub	fp, ip, #4	; 0x4
    feed();
 180:	ebfffff1 	bl	14c <feed>

    // Enabling the PLL */  
    PLLCON = 0x1;
 184:	e59f3050 	ldr	r3, [pc, #80]	; 1dc <sys_init+0x74>
 188:	e3a02001 	mov	r2, #1	; 0x1
 18c:	e5832000 	str	r2, [r3]
    feed();
 190:	ebffffed 	bl	14c <feed>

    // Wait for the PLL to lock to set frequency
    while (!(PLLSTAT & PLOCK));
 194:	e59f3044 	ldr	r3, [pc, #68]	; 1e0 <sys_init+0x78>
 198:	e5933000 	ldr	r3, [r3]
 19c:	e3130b01 	tst	r3, #1024	; 0x400
 1a0:	0afffffb 	beq	194 <sys_init+0x2c>

    // Connect the PLL as the clock source
    PLLCON = 0x3;
 1a4:	e59f3030 	ldr	r3, [pc, #48]	; 1dc <sys_init+0x74>
 1a8:	e3a04003 	mov	r4, #3	; 0x3
 1ac:	e5834000 	str	r4, [r3]
    feed();
 1b0:	ebffffe5 	bl	14c <feed>

    // Enabling MAM and setting number of clocks used for Flash memory fetch
    MAMTIM = 0x3;
 1b4:	e59f3028 	ldr	r3, [pc, #40]	; 1e4 <sys_init+0x7c>
 1b8:	e5834000 	str	r4, [r3]
    MAMCR = 0x2;
 1bc:	e59f3024 	ldr	r3, [pc, #36]	; 1e8 <sys_init+0x80>
 1c0:	e3a02002 	mov	r2, #2	; 0x2
 1c4:	e5832000 	str	r2, [r3]

    // Setting peripheral Clock (pclk) to System Clock (cclk)
    VPBDIV = 0x1;
 1c8:	e59f301c 	ldr	r3, [pc, #28]	; 1ec <sys_init+0x84>
 1cc:	e3a02001 	mov	r2, #1	; 0x1
 1d0:	e5832000 	str	r2, [r3]
 1d4:	e91ba810 	ldmdb	fp, {r4, fp, sp, pc}
 1d8:	e01fc084 	ands	ip, pc, r4, lsl #1
 1dc:	e01fc080 	ands	ip, pc, r0, lsl #1
 1e0:	e01fc088 	ands	ip, pc, r8, lsl #1
 1e4:	e01fc004 	ands	ip, pc, r4
 1e8:	e01fc000 	ands	ip, pc, r0
 1ec:	e01fc100 	ands	ip, pc, r0, lsl #2

000001f0 <_sbrk_r>:
}





/* "malloc clue function" */

	/**** Locally used variables. ****/
extern char end[];              /*  end is set in the linker command 	*/
				/* file and is the end of statically 	*/
				/* allocated data (thus start of heap).	*/

static char *heap_ptr;		/* Points to current end of the heap.	*/

/************************** _sbrk_r *************************************/
/*  Support function.  Adjusts end of heap to provide more memory to	*/
/* memory allocator. Simple and dumb with no sanity checks.		*/
/*  struct _reent *r	-- re-entrancy structure, used by newlib to 	*/
/*			support multiple threads of operation.		*/
/*  ptrdiff_t nbytes	-- number of bytes to add.			*/
/*  Returns pointer to start of new heap area.				*/
/*  Note:  This implementation is not thread safe (despite taking a	*/
/* _reent structure as a parameter).  					*/
/*  Since _s_r is not used in the current implementation, the following	*/
/* messages must be suppressed.						*/

void * _sbrk_r(
    struct _reent *_s_r, 
    ptrdiff_t nbytes)
{
	char  *base;		/*  errno should be set to  ENOMEM on error	*/

	if (!heap_ptr) {	/*  Initialize if first time through.		*/
 1f0:	e59f2020 	ldr	r2, [pc, #32]	; 218 <_sbrk_r+0x28>
 1f4:	e5923000 	ldr	r3, [r2]
 1f8:	e3530000 	cmp	r3, #0	; 0x0
		heap_ptr = end;
 1fc:	059f3018 	ldreq	r3, [pc, #24]	; 21c <_sbrk_r+0x2c>
 200:	05823000 	streq	r3, [r2]
	}
	base = heap_ptr;	/*  Point to end of heap.			*/
 204:	e5923000 	ldr	r3, [r2]
	heap_ptr += nbytes;	/*  Increase heap.				*/
	
	return base;		/*  Return pointer to start of new heap area.	*/
}
 208:	e1a00003 	mov	r0, r3
 20c:	e0833001 	add	r3, r3, r1
 210:	e5823000 	str	r3, [r2]
 214:	e1a0f00e 	mov	pc, lr
 218:	40000000 	andmi	r0, r0, r0
 21c:	40000500 	andmi	r0, r0, r0, lsl #10

00000220 <enableIRQ>:

static inline unsigned asm_get_cpsr(void)
{
  unsigned long retval;
  asm volatile (" mrs  %0, cpsr" : "=r" (retval) : /* no inputs */  );
 220:	e10f0000 	mrs	r0, CPSR
  return retval;
}

static inline void asm_set_cpsr(unsigned val)
{
 224:	e3c03080 	bic	r3, r0, #128	; 0x80
  asm volatile (" msr  cpsr, %0" : /* no outputs */ : "r" (val)  );
 228:	e129f003 	msr	CPSR_fc, r3
}

unsigned enableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr & ~IRQ_MASK);
  return _cpsr;
}
 22c:	e1a0f00e 	mov	pc, lr

00000230 <disableIRQ>:
 230:	e10f0000 	mrs	r0, CPSR
 234:	e3803080 	orr	r3, r0, #128	; 0x80
 238:	e129f003 	msr	CPSR_fc, r3

unsigned disableIRQ(void)
{
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr(_cpsr | IRQ_MASK);
  return _cpsr;
}
 23c:	e1a0f00e 	mov	pc, lr

00000240 <restoreIRQ>:

unsigned restoreIRQ(unsigned oldCPSR)
{
 240:	e1a02000 	mov	r2, r0
 244:	e10f0000 	mrs	r0, CPSR
 248:	e2022080 	and	r2, r2, #128	; 0x80
 24c:	e3c03080 	bic	r3, r0, #128	; 0x80
 250:	e1833002 	orr	r3, r3, r2
 254:	e129f003 	msr	CPSR_fc, r3
  unsigned _cpsr;

  _cpsr = asm_get_cpsr();
  asm_set_cpsr((_cpsr & ~IRQ_MASK) | (oldCPSR & IRQ_MASK));
  return _cpsr;
}
 258:	e1a0f00e 	mov	pc, lr

0000025c <adc_init>:
void adc_init()
{
	PINSEL1|=(1<<24);
 25c:	e59f202c 	ldr	r2, [pc, #44]	; 290 <adc_init+0x34>
 260:	e5923000 	ldr	r3, [r2]
 264:	e3833401 	orr	r3, r3, #16777216	; 0x1000000
 268:	e5823000 	str	r3, [r2]
	PINSEL1&=~(1<<25);//AD0.2 at P0.29
 26c:	e5923000 	ldr	r3, [r2]
 270:	e3c33402 	bic	r3, r3, #33554432	; 0x2000000
 274:	e5823000 	str	r3, [r2]
	
	AD0CR|=(1<<1)|(12<<8)|(1<<16)|(1<<21);//AD0.2 ;VPB clock (PCLK) value=12;burst mode;PDN=1
 278:	e59f1014 	ldr	r1, [pc, #20]	; 294 <adc_init+0x38>
 27c:	e59f3014 	ldr	r3, [pc, #20]	; 298 <adc_init+0x3c>
 280:	e5912000 	ldr	r2, [r1]
 284:	e1823003 	orr	r3, r2, r3
 288:	e5813000 	str	r3, [r1]
 28c:	e1a0f00e 	mov	pc, lr
 290:	e002c004 	and	ip, r2, r4
 294:	e0034000 	and	r4, r3, r0
 298:	00210c02 	eoreq	r0, r1, r2, lsl #24

0000029c <adc_read>:
}

unsigned int adc_read()
{
	//AD0CR|=(1<<24);//001=Start conversion now.
	
	while(!(AD0DR1&(1<<31)));//This bit is set to 1 when an A/D conversion completes,hence poll till it becomes 1.
 29c:	e59f201c 	ldr	r2, [pc, #28]	; 2c0 <adc_read+0x24>
 2a0:	e5923000 	ldr	r3, [r2]
 2a4:	e3530000 	cmp	r3, #0	; 0x0
 2a8:	aafffffb 	bge	29c <adc_read>
                               
	return((AD0DR1 & 0x0000FFC0)>>6);//masking(refer notbk)
 2ac:	e5923000 	ldr	r3, [r2]
 2b0:	e59f000c 	ldr	r0, [pc, #12]	; 2c4 <adc_read+0x28>
 2b4:	e0030000 	and	r0, r3, r0
 2b8:	e1a00320 	mov	r0, r0, lsr #6
}
 2bc:	e1a0f00e 	mov	pc, lr
 2c0:	e0034014 	and	r4, r3, r4, lsl r0
 2c4:	0000ffc0 	andeq	pc, r0, r0, asr #31

000002c8 <uart0_init>:
#define val 60000000/(16*baud)
#define baud 9600
void uart0_init()
{
	PINSEL0&=~(1<<1)|(1<<3);
 2c8:	e59f2048 	ldr	r2, [pc, #72]	; 318 <uart0_init+0x50>
 2cc:	e5923000 	ldr	r3, [r2]
 2d0:	e3c33002 	bic	r3, r3, #2	; 0x2
 2d4:	e5823000 	str	r3, [r2]
	PINSEL0|=(1<<0)|(1<<2);
 2d8:	e5923000 	ldr	r3, [r2]
 2dc:	e3833005 	orr	r3, r3, #5	; 0x5
 2e0:	e5823000 	str	r3, [r2]
	
	U0LCR|=(1<<7);// enable DLAB bit
 2e4:	e59f1030 	ldr	r1, [pc, #48]	; 31c <uart0_init+0x54>
 2e8:	e5913000 	ldr	r3, [r1]
 2ec:	e3833080 	orr	r3, r3, #128	; 0x80
 2f0:	e5813000 	str	r3, [r1]
	U0DLL=val&(0xFF);
 2f4:	e59f3024 	ldr	r3, [pc, #36]	; 320 <uart0_init+0x58>
 2f8:	e3a02086 	mov	r2, #134	; 0x86
 2fc:	e5832000 	str	r2, [r3]
	U0DLM=val>>8;
 300:	e59f301c 	ldr	r3, [pc, #28]	; 324 <uart0_init+0x5c>
 304:	e3a02001 	mov	r2, #1	; 0x1
 308:	e5832000 	str	r2, [r3]
	U0LCR=0X03;//parity disable,1 stop bit,8 bit data
 30c:	e3a03003 	mov	r3, #3	; 0x3
 310:	e5813000 	str	r3, [r1]
 314:	e1a0f00e 	mov	pc, lr
 318:	e002c000 	and	ip, r2, r0
 31c:	e000c00c 	and	ip, r0, ip
 320:	e000c000 	and	ip, r0, r0
 324:	e000c004 	and	ip, r0, r4

00000328 <uart0_tx_char>:
}

void uart0_tx_char(unsigned char data)
{
 328:	e20000ff 	and	r0, r0, #255	; 0xff
	while(!(U0LSR&(1<<5)));  
 32c:	e59f3014 	ldr	r3, [pc, #20]	; 348 <uart0_tx_char+0x20>
 330:	e5933000 	ldr	r3, [r3]
 334:	e3130020 	tst	r3, #32	; 0x20
 338:	159f300c 	ldrne	r3, [pc, #12]	; 34c <uart0_tx_char+0x24>
 33c:	15830000 	strne	r0, [r3]
 340:	11a0f00e 	movne	pc, lr
 344:	eafffff8 	b	32c <uart0_tx_char+0x4>
 348:	e000c014 	and	ip, r0, r4, lsl r0
 34c:	e000c000 	and	ip, r0, r0

00000350 <uart0_tx_str>:
	U0THR=data;
}	

void uart0_tx_str(unsigned char *ptr) 
{
 350:	e1a0c00d 	mov	ip, sp
 354:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
 358:	e1a04000 	mov	r4, r0
    while(*ptr !='\0')
 35c:	e5d00000 	ldrb	r0, [r0]
 360:	e3500000 	cmp	r0, #0	; 0x0
 364:	e24cb004 	sub	fp, ip, #4	; 0x4
 368:	091ba810 	ldmeqdb	fp, {r4, fp, sp, pc}
	{
	uart0_tx_char(*ptr);
 36c:	e20000ff 	and	r0, r0, #255	; 0xff
 370:	ebffffec 	bl	328 <uart0_tx_char>
	ptr ++; // uart1_tx_char(*(ptr++));
 374:	e5f40001 	ldrb	r0, [r4, #1]!
 378:	e3500000 	cmp	r0, #0	; 0x0
 37c:	091ba810 	ldmeqdb	fp, {r4, fp, sp, pc}
 380:	eafffff9 	b	36c <uart0_tx_str+0x1c>

00000384 <uart0_tx_num>:
	}
}

void uart0_tx_num(unsigned int num ) 
{
 384:	e1a0c00d 	mov	ip, sp
 388:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
 38c:	e24cb004 	sub	fp, ip, #4	; 0x4
 390:	e24dd008 	sub	sp, sp, #8	; 0x8
	unsigned char i,count[5];	
	
	for(i=1;i<=4;i++)
 394:	e3a04001 	mov	r4, #1	; 0x1
	{
	count[i] = num % 10;
 398:	e59f3060 	ldr	r3, [pc, #96]	; 400 <STACK_SIZE>
 39c:	e0821093 	umull	r1, r2, r3, r0
 3a0:	e24bc010 	sub	ip, fp, #16	; 0x10
 3a4:	e2843001 	add	r3, r4, #1	; 0x1
 3a8:	e1a021a2 	mov	r2, r2, lsr #3
 3ac:	e08c1004 	add	r1, ip, r4
 3b0:	e20340ff 	and	r4, r3, #255	; 0xff
 3b4:	e0823102 	add	r3, r2, r2, lsl #2
 3b8:	e0403083 	sub	r3, r0, r3, lsl #1
 3bc:	e3540004 	cmp	r4, #4	; 0x4
 3c0:	e5413008 	strb	r3, [r1, -#8]
	num = num / 10 ;
 3c4:	e1a00002 	mov	r0, r2
 3c8:	9afffff2 	bls	398 <uart0_tx_num+0x14>
	}
	i--;// At the time of exit from the 'for loop',its value is greater than 1 of max value,
 3cc:	e2443001 	sub	r3, r4, #1	; 0x1
		// in this case it is 6 which is greater than 5;hence to decrease by 1 i--. 
	while(i!=0)
 3d0:	e21340ff 	ands	r4, r3, #255	; 0xff
 3d4:	091ba810 	ldmeqdb	fp, {r4, fp, sp, pc}
	{
	uart0_tx_char(count[i] + 0x30);
 3d8:	e24b1010 	sub	r1, fp, #16	; 0x10
 3dc:	e0813004 	add	r3, r1, r4
 3e0:	e5530008 	ldrb	r0, [r3, -#8]
 3e4:	e2800030 	add	r0, r0, #48	; 0x30
 3e8:	e20000ff 	and	r0, r0, #255	; 0xff
 3ec:	ebffffcd 	bl	328 <uart0_tx_char>
	i--;
 3f0:	e2443001 	sub	r3, r4, #1	; 0x1
 3f4:	e21340ff 	ands	r4, r3, #255	; 0xff
 3f8:	091ba810 	ldmeqdb	fp, {r4, fp, sp, pc}
 3fc:	eafffff5 	b	3d8 <uart0_tx_num+0x54>
 400:	cccccccd 	stcgtl	12, cr12, [ip], #820

00000404 <uart0_rx_char>:
	}
}
unsigned char uart0_rx_char(void)
{
	while(!(U0LSR&(1<<0)));  
 404:	e59f3018 	ldr	r3, [pc, #24]	; 424 <uart0_rx_char+0x20>
 408:	e5933000 	ldr	r3, [r3]
 40c:	e3130001 	tst	r3, #1	; 0x1
 410:	159f3010 	ldrne	r3, [pc, #16]	; 428 <uart0_rx_char+0x24>
 414:	15930000 	ldrne	r0, [r3]
 418:	120000ff 	andne	r0, r0, #255	; 0xff
	return U0RBR;
}
 41c:	11a0f00e 	movne	pc, lr
 420:	eafffff7 	b	404 <uart0_rx_char>
 424:	e000c014 	and	ip, r0, r4, lsl r0
 428:	e000c000 	and	ip, r0, r0

0000042c <uart0_rx_str>:
	
void uart0_rx_str(unsigned char *ptr)
{     unsigned int i;
 42c:	e1a0c00d 	mov	ip, sp
 430:	e92dd830 	stmdb	sp!, {r4, r5, fp, ip, lr, pc}
 434:	e24cb004 	sub	fp, ip, #4	; 0x4
 438:	e1a04000 	mov	r4, r0
      for(i=0;i<100;i++)
 43c:	e3a05000 	mov	r5, #0	; 0x0
      {
       *(ptr+i)=uart0_rx_char();
 440:	ebffffef 	bl	404 <uart0_rx_char>
 444:	e7c40005 	strb	r0, [r4, r5]
        if(*(ptr+i)=='\r')
 448:	e7d43005 	ldrb	r3, [r4, r5]
 44c:	e353000d 	cmp	r3, #13	; 0xd
 450:	03a03000 	moveq	r3, #0	; 0x0
 454:	07c43005 	streqb	r3, [r4, r5]
        {
        *(ptr+i)='\0';
		
        break;
 458:	091ba830 	ldmeqdb	fp, {r4, r5, fp, sp, pc}
 45c:	e2855001 	add	r5, r5, #1	; 0x1
 460:	e3550063 	cmp	r5, #99	; 0x63
 464:	891ba830 	ldmhidb	fp, {r4, r5, fp, sp, pc}
 468:	eafffff4 	b	440 <uart0_rx_str+0x14>

0000046c <uart0_rx_num>:
		}
       }      
}	

// Receiving number
//For 1 digit no.
unsigned char uart0_rx_num(void)
{
 46c:	e1a0c00d 	mov	ip, sp
 470:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
 474:	e24cb004 	sub	fp, ip, #4	; 0x4
	unsigned char num;
	while(1)
	{
	num = uart0_rx_char();
 478:	ebffffe1 	bl	404 <uart0_rx_char>
	num = num - 0x30;
 47c:	e2400030 	sub	r0, r0, #48	; 0x30
 480:	e20000ff 	and	r0, r0, #255	; 0xff
	return num;
	}
}
 484:	e91ba800 	ldmdb	fp, {fp, sp, pc}

00000488 <delay>:
#define LINE1	0x80
#define LINE2	0xC0

void delay(unsigned int i)
{
 488:	e24dd008 	sub	sp, sp, #8	; 0x8
	volatile unsigned int j=0,k = 0;
 48c:	e3a03000 	mov	r3, #0	; 0x0
 490:	e58d3004 	str	r3, [sp, #4]
 494:	e58d3000 	str	r3, [sp]
	for (j=0;j<i;j++)
 498:	e58d3004 	str	r3, [sp, #4]
 49c:	e59d3004 	ldr	r3, [sp, #4]
 4a0:	e1530000 	cmp	r3, r0
 4a4:	2a000011 	bcs	4f0 <delay+0x68>
		for (k=0;k<6000;k++);	// 
 4a8:	e3a03000 	mov	r3, #0	; 0x0
 4ac:	e58d3000 	str	r3, [sp]
 4b0:	e59d3000 	ldr	r3, [sp]
 4b4:	e59f203c 	ldr	r2, [pc, #60]	; 4f8 <delay+0x70>
 4b8:	e1530002 	cmp	r3, r2
 4bc:	8a000005 	bhi	4d8 <delay+0x50>
 4c0:	e59d3000 	ldr	r3, [sp]
 4c4:	e2833001 	add	r3, r3, #1	; 0x1
 4c8:	e58d3000 	str	r3, [sp]
 4cc:	e59d3000 	ldr	r3, [sp]
 4d0:	e1530002 	cmp	r3, r2
 4d4:	9afffff9 	bls	4c0 <delay+0x38>
 4d8:	e59d3004 	ldr	r3, [sp, #4]
 4dc:	e2833001 	add	r3, r3, #1	; 0x1
 4e0:	e58d3004 	str	r3, [sp, #4]
 4e4:	e59d3004 	ldr	r3, [sp, #4]
 4e8:	e1530000 	cmp	r3, r0
 4ec:	3affffed 	bcc	4a8 <delay+0x20>
 4f0:	e28dd008 	add	sp, sp, #8	; 0x8
 4f4:	e1a0f00e 	mov	pc, lr
 4f8:	0000176f 	andeq	r1, r0, pc, ror #14

000004fc <latch>:
}

void latch(void)
{
 4fc:	e1a0c00d 	mov	ip, sp
 500:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
	delay(10);
 504:	e3a0000a 	mov	r0, #10	; 0xa
 508:	e24cb004 	sub	fp, ip, #4	; 0x4
 50c:	ebffffdd 	bl	488 <delay>
	IOSET0 |= (1 << 18);	// LCD_EN = 1
 510:	e59f2024 	ldr	r2, [pc, #36]	; 53c <latch+0x40>
 514:	e5923000 	ldr	r3, [r2]
 518:	e3833701 	orr	r3, r3, #262144	; 0x40000
 51c:	e5823000 	str	r3, [r2]
	delay(10);
 520:	e3a0000a 	mov	r0, #10	; 0xa
 524:	ebffffd7 	bl	488 <delay>
	IOCLR0 |= (1 << 18);
 528:	e59f2010 	ldr	r2, [pc, #16]	; 540 <latch+0x44>
 52c:	e5923000 	ldr	r3, [r2]
 530:	e3833701 	orr	r3, r3, #262144	; 0x40000
 534:	e5823000 	str	r3, [r2]
 538:	e91ba800 	ldmdb	fp, {fp, sp, pc}
 53c:	e0028004 	and	r8, r2, r4
 540:	e002800c 	and	r8, r2, ip

00000544 <lcd2148_cmd>:
}

void lcd2148_cmd(unsigned char cmd)
{
 544:	e1a0c00d 	mov	ip, sp
 548:	e92dd870 	stmdb	sp!, {r4, r5, r6, fp, ip, lr, pc}
	IOCLR0 |= (1 << 16);		// RS = 0, command
 54c:	e59f5058 	ldr	r5, [pc, #88]	; 5ac <lcd2148_cmd+0x68>
 550:	e5953000 	ldr	r3, [r5]
 554:	e3833801 	orr	r3, r3, #65536	; 0x10000
 558:	e5853000 	str	r3, [r5]

	IOCLR0 |= (0x0f << 19);
 55c:	e5953000 	ldr	r3, [r5]
 560:	e383371e 	orr	r3, r3, #7864320	; 0x780000
	IOSET0 |= ((cmd & 0xf0) << 15);	// write higher nibble first
 564:	e59f6044 	ldr	r6, [pc, #68]	; 5b0 <lcd2148_cmd+0x6c>
 568:	e5853000 	str	r3, [r5]
 56c:	e5963000 	ldr	r3, [r6]
 570:	e20020f0 	and	r2, r0, #240	; 0xf0
 574:	e1833782 	orr	r3, r3, r2, lsl #15
 578:	e5863000 	str	r3, [r6]
 57c:	e24cb004 	sub	fp, ip, #4	; 0x4
 580:	e1a04000 	mov	r4, r0
	latch();
 584:	ebffffdc 	bl	4fc <latch>

	IOCLR0 |= (0x0f << 19);
 588:	e5953000 	ldr	r3, [r5]
 58c:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 590:	e5853000 	str	r3, [r5]
	IOSET0 |= ((cmd & 0x0f) << 19);	// write lower nibble
 594:	e5963000 	ldr	r3, [r6]
 598:	e204400f 	and	r4, r4, #15	; 0xf
 59c:	e1833984 	orr	r3, r3, r4, lsl #19
 5a0:	e5863000 	str	r3, [r6]
	latch();
 5a4:	e91b6870 	ldmdb	fp, {r4, r5, r6, fp, sp, lr}
 5a8:	eaffffd3 	b	4fc <latch>
 5ac:	e002800c 	and	r8, r2, ip
 5b0:	e0028004 	and	r8, r2, r4

000005b4 <lcd2148_init>:
}



void lcd2148_init(void)
{
 5b4:	e1a0c00d 	mov	ip, sp
 5b8:	e92dd830 	stmdb	sp!, {r4, r5, fp, ip, lr, pc}
 5bc:	e24cb004 	sub	fp, ip, #4	; 0x4
	sys_init();//for pll
 5c0:	ebfffee8 	bl	168 <sys_init>
	PINSEL1&=~((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<7)|(1<<8)|(1<<9)|(1<<10)|(1<<11)|(1<<12)|(1<<13));
 5c4:	e59f20e4 	ldr	r2, [pc, #228]	; 6b0 <lcd2148_init+0xfc>
 5c8:	e5923000 	ldr	r3, [r2]
 5cc:	e3c33dff 	bic	r3, r3, #16320	; 0x3fc0
 5d0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
 5d4:	e5823000 	str	r3, [r2]
	IODIR0|=(1<<16)|(1<<17)|(1<<18)|(1<<19)|(1<<20)|(1<<21)|(1<<22);//AS O/P
 5d8:	e59f20d4 	ldr	r2, [pc, #212]	; 6b4 <lcd2148_init+0x100>
 5dc:	e5923000 	ldr	r3, [r2]
 5e0:	e383387f 	orr	r3, r3, #8323072	; 0x7f0000
 5e4:	e5823000 	str	r3, [r2]
	IOCLR0 |= 0x00007F00;
 5e8:	e59f40c8 	ldr	r4, [pc, #200]	; 6b8 <lcd2148_init+0x104>
 5ec:	e5943000 	ldr	r3, [r4]
 5f0:	e3833c7f 	orr	r3, r3, #32512	; 0x7f00
 5f4:	e5843000 	str	r3, [r4]
	
	delay(100);
 5f8:	e3a00064 	mov	r0, #100	; 0x64
 5fc:	ebffffa1 	bl	488 <delay>
	IOCLR0 |= (0xf << 19);
 600:	e5943000 	ldr	r3, [r4]
 604:	e383371e 	orr	r3, r3, #7864320	; 0x780000
	IOSET0 |= (3 << 19);		// cmd(0x30)
 608:	e59f50ac 	ldr	r5, [pc, #172]	; 6bc <lcd2148_init+0x108>
 60c:	e5843000 	str	r3, [r4]
 610:	e5953000 	ldr	r3, [r5]
 614:	e3833706 	orr	r3, r3, #1572864	; 0x180000
 618:	e5853000 	str	r3, [r5]
	latch();
 61c:	ebffffb6 	bl	4fc <latch>

	delay(5);
 620:	e3a00005 	mov	r0, #5	; 0x5
 624:	ebffff97 	bl	488 <delay>
	IOCLR0 |= (0xf << 19);
 628:	e5943000 	ldr	r3, [r4]
 62c:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 630:	e5843000 	str	r3, [r4]
	IOSET0 |= (3 << 19);		// cmd(0x30)
 634:	e5953000 	ldr	r3, [r5]
 638:	e3833706 	orr	r3, r3, #1572864	; 0x180000
 63c:	e5853000 	str	r3, [r5]
	latch();
 640:	ebffffad 	bl	4fc <latch>
	
	delay(1);
 644:	e3a00001 	mov	r0, #1	; 0x1
 648:	ebffff8e 	bl	488 <delay>
	IOCLR0 |= (0xf << 19);
 64c:	e5943000 	ldr	r3, [r4]
 650:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 654:	e5843000 	str	r3, [r4]
	IOSET0 |= (3 << 19);		// cmd(0x30)
 658:	e5953000 	ldr	r3, [r5]
 65c:	e3833706 	orr	r3, r3, #1572864	; 0x180000
 660:	e5853000 	str	r3, [r5]
	latch();
 664:	ebffffa4 	bl	4fc <latch>

	IOCLR0 |= (0xf << 19);
 668:	e5943000 	ldr	r3, [r4]
 66c:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 670:	e5843000 	str	r3, [r4]
	IOSET0 |= (2 << 19);		// cmd(0x20), 4-bit mode
 674:	e5953000 	ldr	r3, [r5]
 678:	e3833601 	orr	r3, r3, #1048576	; 0x100000
 67c:	e5853000 	str	r3, [r5]
	latch();					// LCD_EN pulse
 680:	ebffff9d 	bl	4fc <latch>
	
	lcd2148_cmd(0x28);			// 2 line display, 5x8 display
 684:	e3a00028 	mov	r0, #40	; 0x28
 688:	ebffffad 	bl	544 <lcd2148_cmd>
	lcd2148_cmd(0x0f);			// display ON, cursor ON, blink ON
 68c:	e3a0000f 	mov	r0, #15	; 0xf
 690:	ebffffab 	bl	544 <lcd2148_cmd>
	lcd2148_cmd(0x01);			// clear display
 694:	e3a00001 	mov	r0, #1	; 0x1
 698:	ebffffa9 	bl	544 <lcd2148_cmd>
	lcd2148_cmd(0x02);			// cursor home
 69c:	e3a00002 	mov	r0, #2	; 0x2
 6a0:	ebffffa7 	bl	544 <lcd2148_cmd>
	lcd2148_cmd(0x06);			// increment cursor by 1, no shift
 6a4:	e3a00006 	mov	r0, #6	; 0x6
 6a8:	e91b6830 	ldmdb	fp, {r4, r5, fp, sp, lr}
 6ac:	eaffffa4 	b	544 <lcd2148_cmd>
 6b0:	e002c004 	and	ip, r2, r4
 6b4:	e0028008 	and	r8, r2, r8
 6b8:	e002800c 	and	r8, r2, ip
 6bc:	e0028004 	and	r8, r2, r4

000006c0 <lcd2148_data>:
}
void lcd2148_data(unsigned char data)
{
 6c0:	e1a0c00d 	mov	ip, sp
 6c4:	e92dd870 	stmdb	sp!, {r4, r5, r6, fp, ip, lr, pc}
	IOSET0 |= (1 << 16);		// RS = 1, data
 6c8:	e59f6058 	ldr	r6, [pc, #88]	; 728 <lcd2148_data+0x68>
 6cc:	e5963000 	ldr	r3, [r6]
 6d0:	e3833801 	orr	r3, r3, #65536	; 0x10000
 6d4:	e5863000 	str	r3, [r6]

	IOCLR0 |= (0x0f << 19);
 6d8:	e59f504c 	ldr	r5, [pc, #76]	; 72c <lcd2148_data+0x6c>
 6dc:	e5953000 	ldr	r3, [r5]
 6e0:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 6e4:	e5853000 	str	r3, [r5]
	IOSET0 |= ((data & 0xf0) << 15);	// write higher nibble first
 6e8:	e5963000 	ldr	r3, [r6]
 6ec:	e20020f0 	and	r2, r0, #240	; 0xf0
 6f0:	e1833782 	orr	r3, r3, r2, lsl #15
 6f4:	e5863000 	str	r3, [r6]
 6f8:	e24cb004 	sub	fp, ip, #4	; 0x4
 6fc:	e1a04000 	mov	r4, r0
	latch();
 700:	ebffff7d 	bl	4fc <latch>

	IOCLR0 |= (0x0f << 19);
 704:	e5953000 	ldr	r3, [r5]
 708:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 70c:	e5853000 	str	r3, [r5]
	IOSET0 |= ((data & 0x0f) << 19);	// write lower nibble
 710:	e5963000 	ldr	r3, [r6]
 714:	e204400f 	and	r4, r4, #15	; 0xf
 718:	e1833984 	orr	r3, r3, r4, lsl #19
 71c:	e5863000 	str	r3, [r6]
	latch();
 720:	e91b6870 	ldmdb	fp, {r4, r5, r6, fp, sp, lr}
 724:	eaffff74 	b	4fc <latch>
 728:	e0028004 	and	r8, r2, r4
 72c:	e002800c 	and	r8, r2, ip

00000730 <lcd2148_string>:
}
void lcd2148_string(unsigned char str[32])
{
 730:	e1a0c00d 	mov	ip, sp
 734:	e92dd8f0 	stmdb	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
	unsigned char k=0;

	IOCLR0 |= ((1 << 16)|(1 << 17)|(1 << 18));	
 738:	e59f30ac 	ldr	r3, [pc, #172]	; 7ec <lcd2148_string+0xbc>
 73c:	e5932000 	ldr	r2, [r3]
 740:	e3822807 	orr	r2, r2, #458752	; 0x70000
 744:	e5832000 	str	r2, [r3]
	while(str[k]!='\0')	//Till null character is encountered
 748:	e5d03000 	ldrb	r3, [r0]
 74c:	e3530000 	cmp	r3, #0	; 0x0
 750:	e24cb004 	sub	fp, ip, #4	; 0x4
 754:	e1a05000 	mov	r5, r0
 758:	e3a07000 	mov	r7, #0	; 0x0
 75c:	091ba8f0 	ldmeqdb	fp, {r4, r5, r6, r7, fp, sp, pc}
		{
			if(k==16) // As LCD is 16x2
 760:	e3570010 	cmp	r7, #16	; 0x10
 764:	e59f4084 	ldr	r4, [pc, #132]	; 7f0 <lcd2148_string+0xc0>
 768:	e59f607c 	ldr	r6, [pc, #124]	; 7ec <lcd2148_string+0xbc>
 76c:	e3a000c0 	mov	r0, #192	; 0xc0
				lcd2148_cmd(LINE2);// go to the LINE 2
 770:	0bffff73 	bleq	544 <lcd2148_cmd>

			IOSET0 |= (1 << 16);	// RS = 1, data
 774:	e5943000 	ldr	r3, [r4]
 778:	e3833801 	orr	r3, r3, #65536	; 0x10000
 77c:	e5843000 	str	r3, [r4]
			IOCLR0 |= (0x0f << 19);
 780:	e5963000 	ldr	r3, [r6]
 784:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 788:	e5863000 	str	r3, [r6]
			IOSET0 |= ((str[k]& 0xf0) << 15);	// write higher nibble first
 78c:	e7d53007 	ldrb	r3, [r5, r7]
 790:	e5942000 	ldr	r2, [r4]
 794:	e20330f0 	and	r3, r3, #240	; 0xf0
 798:	e1822783 	orr	r2, r2, r3, lsl #15
 79c:	e5842000 	str	r2, [r4]
			latch();
 7a0:	ebffff55 	bl	4fc <latch>
			IOSET0 |= (1 << 16);// RS = 1, data
 7a4:	e5943000 	ldr	r3, [r4]
 7a8:	e3833801 	orr	r3, r3, #65536	; 0x10000
 7ac:	e5843000 	str	r3, [r4]
			IOCLR0 |= (0x0f << 19);
 7b0:	e5963000 	ldr	r3, [r6]
 7b4:	e383371e 	orr	r3, r3, #7864320	; 0x780000
 7b8:	e5863000 	str	r3, [r6]
			IOSET0 |= ((str[k] & 0x0f) << 19);	// write lower nibble
 7bc:	e7d53007 	ldrb	r3, [r5, r7]
 7c0:	e5942000 	ldr	r2, [r4]
 7c4:	e203300f 	and	r3, r3, #15	; 0xf
 7c8:	e1822983 	orr	r2, r2, r3, lsl #19
 7cc:	e5842000 	str	r2, [r4]
			latch();
 7d0:	ebffff49 	bl	4fc <latch>
			
			k++;
 7d4:	e2873001 	add	r3, r7, #1	; 0x1
 7d8:	e20370ff 	and	r7, r3, #255	; 0xff
 7dc:	e7d53007 	ldrb	r3, [r5, r7]
 7e0:	e3530000 	cmp	r3, #0	; 0x0
 7e4:	091ba8f0 	ldmeqdb	fp, {r4, r5, r6, r7, fp, sp, pc}
 7e8:	eaffffdc 	b	760 <lcd2148_string+0x30>
 7ec:	e002800c 	and	r8, r2, ip
 7f0:	e0028004 	and	r8, r2, r4

000007f4 <lcd2148_showvalue>:
		}
}
/*
voT=(num - (H*100))/10;id lcd2148_showvalue(unsigned char num)	//prints the decimal 3 digit value of num
{
	unsigned char H=0,T=0,O=0;
	H=num/100;//calculating 100th place no. by dividing by 100
	T=(num - (H*100))/10;//calculating 10th place no. by substracting 100th place no.& then 2 digit no. divided by 10
	O=(num - (H*100) - (T*10));//calculating unit place no.by substracting 100th place & 10th place no.
	
	lcd2148_data(H+48);//Sending ASCII values
	lcd2148_data(T+48);
	lcd2148_data(O+48);
}
*/

void lcd2148_showvalue(unsigned char num)	//prints the decimal 3 digit value of num
{
 7f4:	e1a0c00d 	mov	ip, sp
	unsigned char t=0, H=0,T=0,O=0;
	t=num/1000;
 7f8:	e59f30a0 	ldr	r3, [pc, #160]	; 8a0 <lcd2148_showvalue+0xac>
 7fc:	e92dd870 	stmdb	sp!, {r4, r5, r6, fp, ip, lr, pc}
 800:	e20050ff 	and	r5, r0, #255	; 0xff
 804:	e0c02593 	smull	r2, r0, r3, r5
 808:	e1a00320 	mov	r0, r0, lsr #6
 80c:	e20000ff 	and	r0, r0, #255	; 0xff
	H=(num - (t*1000))/100;
 810:	e0603280 	rsb	r3, r0, r0, lsl #5
 814:	e0803103 	add	r3, r0, r3, lsl #2
 818:	e0455183 	sub	r5, r5, r3, lsl #3
 81c:	e59f3080 	ldr	r3, [pc, #128]	; 8a4 <lcd2148_showvalue+0xb0>
 820:	e0c32395 	smull	r2, r3, r5, r3
 824:	e1a06fc5 	mov	r6, r5, asr #31
 828:	e06662c3 	rsb	r6, r6, r3, asr #5
 82c:	e20660ff 	and	r6, r6, #255	; 0xff
	T=(num - (t*1000) - (H*100))/10;
 830:	e0863106 	add	r3, r6, r6, lsl #2
 834:	e0833103 	add	r3, r3, r3, lsl #2
 838:	e0455103 	sub	r5, r5, r3, lsl #2
 83c:	e59f3064 	ldr	r3, [pc, #100]	; 8a8 <lcd2148_showvalue+0xb4>
 840:	e0c32395 	smull	r2, r3, r5, r3
 844:	e1a04fc5 	mov	r4, r5, asr #31
 848:	e0644143 	rsb	r4, r4, r3, asr #2
 84c:	e20440ff 	and	r4, r4, #255	; 0xff
	//H=num/100;//calculating 100th place no. by dividing by 100
	//T=(num - (H*100))/10;//calculating 10th place no. by substracting 100th place no.& then 2 digit no. divided by 10
	O=(num - (t*1000)- (H*100) - (T*10));//calculating unit place no.by substracting 100th place & 10th place no.
	
	lcd2148_data(t+48);//Sending ASCII values
 850:	e2800030 	add	r0, r0, #48	; 0x30
	lcd2148_data(H+48);
 854:	e2866030 	add	r6, r6, #48	; 0x30
 858:	e0843104 	add	r3, r4, r4, lsl #2
 85c:	e24cb004 	sub	fp, ip, #4	; 0x4
 860:	e20000ff 	and	r0, r0, #255	; 0xff
 864:	e20660ff 	and	r6, r6, #255	; 0xff
	lcd2148_data(T+48);
 868:	e2844030 	add	r4, r4, #48	; 0x30
 86c:	e0455083 	sub	r5, r5, r3, lsl #1
 870:	e20440ff 	and	r4, r4, #255	; 0xff
 874:	ebffff91 	bl	6c0 <lcd2148_data>
 878:	e1a00006 	mov	r0, r6
 87c:	ebffff8f 	bl	6c0 <lcd2148_data>
 880:	e1a00004 	mov	r0, r4
 884:	ebffff8d 	bl	6c0 <lcd2148_data>
 888:	e20550ff 	and	r5, r5, #255	; 0xff
	lcd2148_data(O+48);
 88c:	e2855030 	add	r5, r5, #48	; 0x30
 890:	e20550ff 	and	r5, r5, #255	; 0xff
 894:	e1a00005 	mov	r0, r5
 898:	e91b6870 	ldmdb	fp, {r4, r5, r6, fp, sp, lr}
 89c:	eaffff87 	b	6c0 <lcd2148_data>
 8a0:	10624dd3 	ldrned	r4, [r2], -#211
 8a4:	51eb851f 	mvnpl	r8, pc, lsl r5
 8a8:	66666667 	strvsbt	r6, [r6], -r7, ror #12

000008ac <lcd2148_gotoxy1>:
}

void lcd2148_gotoxy1(unsigned char pos)
{
	lcd2148_cmd(LINE1+pos);
 8ac:	e2400080 	sub	r0, r0, #128	; 0x80
 8b0:	e20000ff 	and	r0, r0, #255	; 0xff
 8b4:	eaffff22 	b	544 <lcd2148_cmd>

000008b8 <lcd2148_gotoxy2>:
}

void lcd2148_gotoxy2(unsigned char pos)
{
	lcd2148_cmd(LINE2+pos);
 8b8:	e2400040 	sub	r0, r0, #64	; 0x40
 8bc:	e20000ff 	and	r0, r0, #255	; 0xff
 8c0:	eaffff1f 	b	544 <lcd2148_cmd>

000008c4 <main>:
#include"adc_burst.h"
#include"uart.h"
#include"lcd_2148.h"
int main()
{	unsigned int a=0,c=0,z;
 8c4:	e1a0c00d 	mov	ip, sp
 8c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
 8cc:	e24cb004 	sub	fp, ip, #4	; 0x4
	sys_init();//for pll
 8d0:	ebfffe24 	bl	168 <sys_init>
	adc_init();
 8d4:	ebfffe60 	bl	25c <adc_init>
	lcd2148_init();
 8d8:	ebffff35 	bl	5b4 <lcd2148_init>
	uart0_init();
 8dc:	ebfffe79 	bl	2c8 <uart0_init>
	 lcd2148_showvalue(1234);
 8e0:	e3a000d2 	mov	r0, #210	; 0xd2
 8e4:	ebffffc2 	bl	7f4 <lcd2148_showvalue>
/*
	while(1)
	{
		for(z=0;z<=9;z++)
		{
			a=adc_read();
			//uart0_tx_num(a); 
			lcd2148_showvalue(a);
			c=c+a;
			delay(2000);
			//uart0_tx_num(c); 
			//uart0_tx_str("\n");
			lcd2148_cmd(0x01);
		}
		lcd2148_string("Avg val = ");
		//uart0_tx_str("Average value = ");
		c=c/10;
		lcd2148_gotoxy1(11);
		lcd2148_showvalue(c);
		//uart0_tx_str("\n");
	
		
	}*/
	
}	
 8e8:	e3a00000 	mov	r0, #0	; 0x0
 8ec:	e91ba800 	ldmdb	fp, {fp, sp, pc}
